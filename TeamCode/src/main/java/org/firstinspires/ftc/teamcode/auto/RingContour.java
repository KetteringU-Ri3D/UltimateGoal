package org.firstinspires.ftc.teamcode.auto;

import org.firstinspires.ftc.robotcore.external.Telemetry;
import org.opencv.core.Core;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.core.MatOfPoint;
import org.opencv.core.MatOfPoint2f;
import org.opencv.core.Rect;
import org.opencv.core.Scalar;
import org.opencv.imgproc.Imgproc;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
* RingContour class.
*
* <p>An OpenCV pipeline generated by GRIP.
*
* @author GRIP
*/
public class RingContour {

	//Outputs
	private Mat hsvThresholdOutput = new Mat();
	private Mat blurOutput = new Mat();
	private Mat maskOutput = new Mat();
	private ArrayList<MatOfPoint> findContoursOutput = new ArrayList<MatOfPoint>();
	private static final int oneRingAreaLowBound = 2000;
	private static final int oneRingAreaHighBound = 4000;
	private static final int fourRingAreaLowBound = 5000;
	private static final int fourRingAreaHighBound = 7000;
	private ArrayList<Double> ringDetermination = new ArrayList<>();

	/**
	 * This is the primary method that runs the entire pipeline and updates the outputs.
	 */
	public Mat process(Mat source0, Telemetry telemetry) {
		Mat convertedSource = new Mat();
		source0.convertTo(convertedSource, Imgproc.COLOR_RGB2HSV);
		// Step HSV_Threshold0:
		Mat hsvThresholdInput = source0;
		double[] hsvThresholdHue = {6.474820143884893, 30.95221843003414};
		double[] hsvThresholdSaturation = {123.83093525179856, 255.0};
		double[] hsvThresholdValue = {71.08812949640289, 216};
		hsvThreshold(hsvThresholdInput, hsvThresholdHue, hsvThresholdSaturation, hsvThresholdValue, hsvThresholdOutput);

		// Step Find_Contours0:
		Mat findContoursInput = maskOutput;
		boolean findContoursExternalOnly = false;
		findContours(findContoursInput, findContoursExternalOnly, findContoursOutput);

		List<MatOfPoint> contours = new ArrayList<>();
		Mat hierarchy = new Mat();
		Mat cannyOutput = new Mat();
		int threshold = 200;
		Imgproc.Canny(hsvThresholdOutput, cannyOutput, threshold, threshold * 2);
		Imgproc.findContours(cannyOutput, contours, hierarchy, Imgproc.RETR_TREE, Imgproc.CHAIN_APPROX_SIMPLE);

		MatOfPoint2f[] contoursPoly  = new MatOfPoint2f[contours.size()];
		Rect[] boundRect = new Rect[contours.size()];

		for (int i = 0; i < contours.size(); i++) {
			contoursPoly[i] = new MatOfPoint2f();
			Imgproc.approxPolyDP(new MatOfPoint2f(contours.get(i).toArray()), contoursPoly[i], 3, true);
			boundRect[i] = Imgproc.boundingRect(new MatOfPoint(contoursPoly[i].toArray()));
		}

		Mat drawing = Mat.zeros(cannyOutput.size(), CvType.CV_8UC3);
		List<MatOfPoint> contoursPolyList = new ArrayList<>(contoursPoly.length);
		for (MatOfPoint2f poly : contoursPoly) {
			contoursPolyList.add(new MatOfPoint(poly.toArray()));
		}

		for (int i = 0; i < contours.size(); i++) {
			Scalar color = new Scalar(145, 50, 189);
			Scalar color1 = new Scalar(125, 89, 255);
			Scalar color2 = new Scalar(156, 128, 10);
			Scalar color3 = new Scalar(10, 50, 189);
			Imgproc.drawContours(drawing, contoursPolyList, i, color);
			double xChange = Math.abs(boundRect[i].tl().x - boundRect[i].br().x);
			double yChange = Math.abs(boundRect[i].tl().y - boundRect[i].br().y);
			double area = xChange * yChange;
			if(area > 3000) {
				telemetry.addData("Area- ", area);
				telemetry.addData("Ratio- ", yChange/xChange);
				telemetry.addData("X Change- ", xChange);
				telemetry.addData("Y Change- ", yChange);
				telemetry.update();
				Imgproc.rectangle(drawing, boundRect[i].tl(), boundRect[i].br(), color, 2);
				ringDetermination.add(area);
			}
		}

		return drawing;
	}

	public int getRingNumber() {
		Double maxNumber = Collections.max(ringDetermination);
		if(maxNumber < oneRingAreaLowBound) {
			return 0;
		}	else if(maxNumber > oneRingAreaLowBound && maxNumber < oneRingAreaHighBound) {
			return 1;
		} else if (maxNumber > fourRingAreaLowBound && maxNumber < fourRingAreaHighBound) {
			return 4;
		} else {
			return -1;
		}
	}

	/**
	 * This method is a generated getter for the output of a HSV_Threshold.
	 * @return Mat output from HSV_Threshold.
	 */
	public Mat hsvThresholdOutput() {
		return hsvThresholdOutput;
	}

	/**
	 * This method is a generated getter for the output of a Find_Contours.
	 * @return ArrayList<MatOfPoint> output from Find_Contours.
	 */
	public ArrayList<MatOfPoint> findContoursOutput() {
		return findContoursOutput;
	}


	/**
	 * Segment an image based on hue, saturation, and value ranges.
	 *
	 * @param input The image on which to perform the HSL threshold.
	 * @param hue The min and max hue
	 * @param sat The min and max saturation
	 * @param val The min and max value
	 */
	private void hsvThreshold(Mat input, double[] hue, double[] sat, double[] val,
							  Mat out) {
		Mat tmp = new Mat();
		Imgproc.cvtColor(input, tmp, Imgproc.COLOR_RGBA2RGB);
		Imgproc.cvtColor(tmp, out, Imgproc.COLOR_RGB2HSV_FULL);

		Core.inRange(out, new Scalar(hue[0], sat[0], val[0]),
				new Scalar(hue[1], sat[1], val[1]), out);
	}

	/**
	 * Sets the values of pixels in a binary image to their distance to the nearest black pixel.
	 */
	private void findContours(Mat input, boolean externalOnly,
							  List<MatOfPoint> contours) {
		Mat hierarchy = new Mat();
		contours.clear();
		int mode;
		if (externalOnly) {
			mode = Imgproc.RETR_EXTERNAL;
		}
		else {
			mode = Imgproc.RETR_LIST;
		}
		int method = Imgproc.CHAIN_APPROX_SIMPLE;
		Imgproc.findContours(input, contours, hierarchy, mode, method);
	}




}

